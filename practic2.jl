# Определение функции метода Ньютона для поиска корня уравнения.
# r - функция, для которой мы ищем корень
# x - начальное приближение
# epsilon - требуемая точность (по умолчанию 1e-8)
# num_max - максимальное количество итераций (по умолчанию 100)
function newton(r, x; epsilon = 1e-8, num_max = 100)
    dx = r(x)  # Вычисляем значение функции в начальной точке
    x += dx    # Корректируем начальное приближение
    k = 1      # Счётчик итераций

    # Итерационный процесс
    while abs(dx) > epsilon && k < num_max
        dx = r(x)
        x += dx
        k += 1
    end

    # Проверка на достижение требуемой точности
    abs(dx) > epsilon && @warn("Требуемая точность не достигнута")

    return x
end

# 2
# Пример использования newton для нахождения корня функции f(x) = cos(x) - x
# newton(f, 1.0, num_max=50)

# 3
include("p.jl")
# Определение функции для нахождения корней полинома с использованием метода Ньютона
# p - полином, для которого мы ищем корни
# start_value - начальное приближение
# tool - требуемая точность (по умолчанию 1e-8)
function root(p::Polynomial, start_value, tool::AbstractFloat = 1e-8)
    newton(complex(start_value), epsilon=tool) do x
        val, diff = valder(p, x)
        return -val / diff  # Возвращаем производную полинома
    end
end

# Пример использования root для нахождения корня полинома и проверки его корректности
# p = Polynomial([1, 2, 3, 4])
# a = root(p, 1+im)
# p(a) # Должно быть близко к нулю

# 5
# Функция для вычисления логарифма по основанию a от z с заданной точностью
# a - основание логарифма
# z - аргумент логарифма
# ε - требуемая точность (по умолчанию 1e-8)
function logarithm(a, z; ε = 1e-8)
    t = 1.0  # Инициализируем t
    y = 0.0  # Инициализируем y

    # Итеративный процесс для приближения к значению логарифма
    while z < 1 / a || z > a || t > ε
        if z < 1 / a
            z *= a 
            y -= t 
        elseif z > a
            z /= a 
            y += t 
        elseif t > ε
            t /= 2 
            z *= z 
        end
    end
    return y
end

# 6
# Функция для вычисления косинуса x с использованием разложения в ряд Тейлора с n членами
function cosine(x, n)
    s = 1.0  # Инициализируем сумму
    a = 1.0  # Инициализируем текущий член ряда

    # Итеративный процесс для вычисления косинуса
    for k in 1:n-1
        a *= -x^2 / ((2*k) * (2*k - 1)) 
        s += a
    end
    return s
end

# 7
# Функция для вычисления косинуса x с использованием ряда Тейлора в цикле
function cosine(x)
    s = 0.0  # Инициализируем сумму
    a = 1    # Инициализируем текущий член ряда
    k = 1    # Инициализируем счётчик

    # Итеративный процесс для вычисления косинуса
    while s + a != s
        s += a
        a = -a * x^2 / (2k * (2k - 1))
        k += 1
    end
    return s
end

# 8
# Функция для вычисления экспоненты e^x с использованием ряда Тейлора
function exp(x)
    s = 0    # Инициализируем сумму
    a = 1    # Инициализируем текущий член ряда
    k = 0    # Инициализируем счётчик

    # Итеративный процесс для вычисления экспоненты
    while s + a != s
        s += a
        a = a * x / (k + 1)
        k += 1
    end
    return s
end

# 9
# Функция для вычисления функции Бесселя первого рода J_α(x)
# x - аргумент функции
# α - параметр функции
# epsilon - требуемая точность (по умолчанию 1e-8)
# num - максимальное количество итераций (по умолчанию 50)
function Jα(x::T; α = 0, epsilon = 1e-8, num = 50) where T
    s = zero(T)  # Инициализируем сумму
    a = (x / 2)^α / factorial(α)  # Инициализируем текущий член ряда
    k = 0  # Инициализируем счётчик итераций

    # Итеративный процесс для вычисления функции Бесселя
    while s + a != s
        s += a
       
